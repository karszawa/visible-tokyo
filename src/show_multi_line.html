<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
<style>

html, body, #map {
  position: absolute;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

#line_check {
  position: absolute;
  width: 160px;
  height: 350px;
  background-color: rgba(255, 255, 255, 0.85);
  top: 60px;
  bottom: 20px;
  left: 10px;
  margin: 0;
  padding: 0;
}

.stations, .stations svg {
  position: absolute;
}

.stations svg {
  overflow: visible;
  padding-right: 100px;
  font: 10px sans-serif;
}

.stations circle {
  fill: brown;
  stroke: black;
  stroke-width: 1.5px;
}

.controls {
        margin-top: 10px;
        border: 1px solid transparent;
        border-radius: 2px 0 0 2px;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        height: 32px;
        outline: none;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

#pac-input {
        background-color: #fff;
        font-family: Roboto;
        font-size: 15px;
        font-weight: 300;
        margin-left: 12px;
        padding: 0 11px 0 13px;
        text-overflow: ellipsis;
        width: 300px;
}

#pac-input:focus {
        border-color: #4d90fe;
}

.pac-container {
        font-family: Roboto;
}

#type-selector {
        color: #fff;
        background-color: #4d90fe;
        padding: 5px 11px 0px 11px;
}

#type-selector label {
        font-family: Roboto;
        font-size: 13px;
        font-weight: 300;
}

#target {
        width: 345px;
}

</style>
<div id="map"></div>
<div id="line_check"></div>
<input id="pac-input" class="controls" type="text" placeholder="Search Box">
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDEG16WeMaOoAtxtKMfp0YUEM2S2CTksh0&libraries=places"></script>
<script src="./d3CheckBox.js"></script>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script>

const width = 960;
const height = 700;

// Create the Google Map…
const map = new google.maps.Map(d3.select("#map").node(), {
  zoom: 12,
  center: new google.maps.LatLng(35.681167, 139.767052),
  mapTypeId: google.maps.MapTypeId.TERRAIN
});

// Load the station data. When the data comes back, create an overlay.
d3.json("all_stations.json", (error, data) => {

  if (error) throw error;
  const overlay = new google.maps.OverlayView();
  

  checkBox = [];
  checked = {};
  label = [];
  legend = [];
  const line_data = [
    {name:'JR山手線', color:'#77A846'},
    {name:'JR中央線(快速)', color:'#FF8000'},
    {name:'JR中央・総武線', color:'#FFFF00'},
    {name:'東京メトロ銀座線', color:'#F3975F'},
    {name:'東京メトロ丸ノ内線', color:'#FF0000'},
    {name:'東京メトロ日比谷線', color:'#9caeb7'},
    {name:'東京メトロ東西線', color:'#00a7db'},
    {name:'東京メトロ千代田線', color:'#009944'},
    {name:'東京メトロ有楽町線', color:'#d7c447'},
    {name:'東京メトロ半蔵門線', color:'#9b7cb6'},
    {name:'東京メトロ南北線', color:'#00ada9'},
    {name:'東京メトロ副都心線', color:'#bb641d'},
    {name:'都営大江戸線', color:'#b6007a'},
    {name:'都営浅草線', color:'#e85298'},
    {name:'都営三田線', color:'#0079c2'},
    {name:'都営新宿線', color:'#6cbb5a'},
    {name:'京王井の頭線', color:'#555555'},
  ];

  // create area to select lines
  var svg = d3.select("#line_check").append("svg").attr("width", 160).attr("height", 350);

  line_data.forEach((line, i) => {
    // create checkbox
    checkBox.push(new d3CheckBox());
    checkBox[i].size(15).x(25).y(8+i*20).rx(4).ry(4).markStrokeWidth(2).boxStrokeWidth(2).checked(false).clickEvent(function(){
      line_data.forEach((line, i) => {
        checked[line.name] = checkBox[i].checked();
      })
      overlay.draw();
    });
    checked[line.name] = checkBox[i].checked();
    svg.call(checkBox[i]);

    // create text
    label[i] = svg.append("text").attr("x", 45).attr("y", 20+i*20).attr("font-size", 12).text(line.name);
    legend[i] = svg.append("circle")
                    .attr("cx", 12)
                    .attr("cy", 15+i*20)
                    .attr("r", 8)
                    .attr("stroke", null)
                    .attr("fill", line.color);
  })

  // select data depend on line
  function select_line(all_data) {
    selected_data = [];
    for(let v of all_data){
      if(checked[v.line]){
        selected_data.push(v);
      }
    }
    return selected_data;
  }

  circles = [];

  function draw_circle(station_data) {
    circles = [];
    Object.values(select_line(data)).forEach((position) => {
      function get_color(line) {
        console.log(line);
        for(let l of line_data){
          if(l.name == line){
            return l.color;
          }
        }
      }
      [ 0, 1, 2 ].forEach((i) => {
        const options = {
          map: map,
          center: new google.maps.LatLng(position['lat'], position['lng']),
          radius: [ 100, 300, 600 ][i],
          strokeOpacity: 0.1,
          fillColor: get_color(position['line']),
          fillOpacity: 0.7 - i * 0.2
        };

        circles.push(new google.maps.Circle(options));
      });
    });
    return circles;
  }

  function delete_circle(circles) {
    for(let circle of circles){
      circle.setMap(null);
    }
  }

  // Add the container when the overlay is added to the map.
  overlay.onAdd = function() {
    const layer = d3.select(this.getPanes().overlayLayer).append("div")
      .attr("class", "stations");

    const projection = this.getProjection();

    overlay.draw = () => {
      delete_circle(circles);
      circles = draw_circle(select_line(data));
    };
  };

  // Bind our overlay to the map…
  overlay.setMap(map);
  initAutocomplete();
});

// This example adds a search box to a map, using the Google Place Autocomplete
// feature. People can enter geographical searches. The search box will return a
// pick list containing a mix of places and predicted search terms.
// This example requires the Places library. Include the libraries=places
// parameter when you first load the API. For example:
// <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places">
function initAutocomplete() {
  // Create the search box and link it to the UI element.
  var input = document.getElementById('pac-input');
  var searchBox = new google.maps.places.SearchBox(input);
  map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
  // Bias the SearchBox results towards current map's viewport.
  map.addListener('bounds_changed', function() {
    searchBox.setBounds(map.getBounds());
  });
  var markers = [];
  // Listen for the event fired when the user selects a prediction and retrieve
  // more details for that place.
  searchBox.addListener('places_changed', function() {
    var places = searchBox.getPlaces();
    if (places.length == 0) {
      return;
    }
    // Clear out the old markers.
    markers.forEach(function(marker) {
      marker.setMap(null);
    });
    markers = [];
    // For each place, get the icon, name and location.
    var bounds = new google.maps.LatLngBounds();
    places.forEach(function(place) {
      if (!place.geometry) {
        console.log("Returned place contains no geometry");
        return;
      }
      var icon = {
        url: place.icon,
        size: new google.maps.Size(71, 71),
        origin: new google.maps.Point(0, 0),
        anchor: new google.maps.Point(17, 34),
        scaledSize: new google.maps.Size(25, 25)
      };
      // Create a marker for each place.
      markers.push(new google.maps.Marker({
        map: map,
        icon: icon,
        title: place.name,
        position: place.geometry.location
      }));
      if (place.geometry.viewport) {
        // Only geocodes have viewport.
        bounds.union(place.geometry.viewport);
      }
      else {
        bounds.extend(place.geometry.location);
      }
    });
    map.fitBounds(bounds);
  });
}

</script>
